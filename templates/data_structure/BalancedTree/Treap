/**
 *    Treap模板
 *    支持传入不同类型
 *    可指定比较函数，默认升序（模板传入）
 *    可指定哨兵值大小（构造函数传入）
**/
template<class T, class U = std::size_t, class Compare = std::less<T>>
struct Treap {
 private:
  struct Node {
    T key;
    unsigned int priority;
    U cnt;
    U size;
    int left, right;

    constexpr Node(const T& k, unsigned int prio)
      : key(k), priority(prio), cnt(1), size(1),
        left(-1), right(-1) {}
  };

  std::vector<Node> nodes;
  int root;
  static std::mt19937 rng;
  Compare compare;
  T min_sentinel;  // 最小哨兵值
  T max_sentinel;  // 最大哨兵值

  // 初始化随机数生成器
  static void initRNG() {
    static bool initialized = false;
    if (!initialized) {
      auto seed = static_cast<unsigned int>(
                    std::chrono::duration_cast<std::chrono::milliseconds>(
                      std::chrono::system_clock::now().time_since_epoch()
                    ).count() % 1000000000
                  );
      rng.seed(seed);
      initialized = true;
    }
  }

  constexpr unsigned int getRandomPriority() {
    initRNG();
    return rng();
  }

  constexpr int createNode(const T& key) {
    nodes.emplace_back(key, getRandomPriority());
    return static_cast<int>(nodes.size()) - 1;
  }

  constexpr Node& getNode(int idx) {
    return nodes[idx];
  }

  constexpr const Node& getNode(int idx) const {
    return nodes[idx];
  }

  // 更新节点大小
  constexpr void updateSize(int p) {
    auto& node = getNode(p);
    node.size = node.cnt;
    if (node.left != -1) node.size += getNode(node.left).size;
    if (node.right != -1) node.size += getNode(node.right).size;
  }

  // 左旋
  constexpr void rotateLeft(int& p) {
    int q = getNode(p).right;
    getNode(p).right = getNode(q).left;
    getNode(q).left = p;
    updateSize(p);
    updateSize(q);
    p = q;
  }

  // 右旋
  constexpr void rotateRight(int& p) {
    int q = getNode(p).left;
    getNode(p).left = getNode(q).right;
    getNode(q).right = p;
    updateSize(p);
    updateSize(q);
    p = q;
  }

  // 插入节点
  constexpr void insert(int& p, const T& key) {
    if (p == -1) {
      p = createNode(key);
      return;
    }

    auto& node = getNode(p);
    if (!compare(key, node.key) && !compare(node.key, key)) {
      // key == node.key
      node.cnt++;
      updateSize(p);
      return;
    }

    if (compare(key, node.key)) {
      insert(node.left, key);
      if (getNode(node.left).priority > node.priority)
        rotateRight(p);
    } else {
      insert(node.right, key);
      if (getNode(node.right).priority > node.priority)
        rotateLeft(p);
    }
    updateSize(p);
  }

  // 删除节点
  constexpr void erase(int& p, const T& key) {
    if (p == -1) return;

    auto& node = getNode(p);
    if (compare(key, node.key)) {
      erase(node.left, key);
    } else if (compare(node.key, key)) {
      erase(node.right, key);
    } else {
      if (node.cnt > 1) {
        node.cnt--;
        updateSize(p);
        return;
      }

      if (node.left == -1 && node.right == -1) {
        p = -1;
        return;
      }

      if (node.left == -1 || (node.right != -1 &&
                              getNode(node.left).priority < getNode(node.right).priority)) {
        rotateLeft(p);
        erase(getNode(p).left, key);
      } else {
        rotateRight(p);
        erase(getNode(p).right, key);
      }
    }

    if (p != -1) updateSize(p);
  }

  // 根据值找排名（1-based）
  constexpr U getRank(int p, const T& key) const {
    if (p == -1) return 0;

    const auto& node = getNode(p);
    U leftSize = (node.left != -1) ? getNode(node.left).size : 0;

    if (!compare(key, node.key) && !compare(node.key, key)) {
      return leftSize + 1;
    } else if (compare(key, node.key)) {
      return getRank(node.left, key);
    } else {
      return leftSize + node.cnt + getRank(node.right, key);
    }
  }

  // 根据排名找值
  constexpr T getByRank(int p, U rank) const {
    const auto& node = getNode(p);
    U leftSize = (node.left != -1) ? getNode(node.left).size : 0;

    if (rank <= leftSize) {
      return getByRank(node.left, rank);
    } else if (rank <= leftSize + node.cnt) {
      return node.key;
    } else {
      return getByRank(node.right, rank - leftSize - node.cnt);
    }
  }

  // 找第一个严格小于x的值
  constexpr T findPrev(int p, const T& x, T best) const {
    if (p == -1) return best;

    const auto& node = getNode(p);
    if (compare(node.key, x)) {
      best = node.key;
      return findPrev(node.right, x, best);
    } else {
      return findPrev(node.left, x, best);
    }
  }

  // 找第一个严格大于x的值
  constexpr T findNext(int p, const T& x, T best) const {
    if (p == -1) return best;

    const auto& node = getNode(p);
    if (compare(x, node.key)) {
      best = node.key;
      return findNext(node.left, x, best);
    } else {
      return findNext(node.right, x, best);
    }
  }

  // 找第一个大于等于x的值
  constexpr T findLowerBound(int p, const T& x, T best) const {
    if (p == -1) return best;

    const auto& node = getNode(p);
    if (!compare(node.key, x)) { // node.key >= x
      best = node.key;
      return findLowerBound(node.left, x, best);
    } else {
      return findLowerBound(node.right, x, best);
    }
  }

  // 找第一个小于等于x的值
  constexpr T findUpperBound(int p, const T& x, T best) const {
    if (p == -1) return best;

    const auto& node = getNode(p);
    if (!compare(x, node.key)) { // node.key <= x
      best = node.key;
      return findUpperBound(node.right, x, best);
    } else {
      return findUpperBound(node.left, x, best);
    }
  }

  // 检查是否为哨兵节点
  constexpr bool isSentinel(const T& value) const {
    return !compare(value, min_sentinel) && !compare(min_sentinel, value) ||
           !compare(value, max_sentinel) && !compare(max_sentinel, value);
  }

 public:
  // 构造函数 - 使用默认哨兵值
  constexpr Treap(const T& min_val, const T& max_val,
                  const Compare& comp = Compare())
    : compare(comp), min_sentinel(min_val), max_sentinel(max_val) {
    init();
  }

  // 构造函数 - 使用默认哨兵值（针对数值类型）
  template<typename = std::enable_if_t<std::is_arithmetic_v<T>>>
                                       constexpr Treap(const Compare& comp = Compare())
                                         : compare(comp),
                                           min_sentinel(std::numeric_limits<T>::min()),
                                           max_sentinel(std::numeric_limits<T>::max()) {
    init();
  }

  // 移动构造函数
  constexpr Treap(Treap&& other) noexcept
    : nodes(std::move(other.nodes)),
      root(other.root),
      compare(std::move(other.compare)),
      min_sentinel(std::move(other.min_sentinel)),
      max_sentinel(std::move(other.max_sentinel)) {
    other.root = -1;
  }

  // 复制构造函数
  constexpr Treap(const Treap& other)
    : nodes(other.nodes),
      root(other.root),
      compare(other.compare),
      min_sentinel(other.min_sentinel),
      max_sentinel(other.max_sentinel) {
  }

  // 赋值运算符
  constexpr Treap& operator=(Treap other) {
    swap(*this, other);
    return *this;
  }

  // 交换函数
  friend constexpr void swap(Treap& a, Treap& b) noexcept {
    using std::swap;
    swap(a.nodes, b.nodes);
    swap(a.root, b.root);
    swap(a.compare, b.compare);
    swap(a.min_sentinel, b.min_sentinel);
    swap(a.max_sentinel, b.max_sentinel);
  }

  // 初始化（添加两个哨兵节点）
  constexpr void init() {
    nodes.clear();
    nodes.reserve(100010);

    // 添加哨兵节点
    int node1 = createNode(min_sentinel);
    int node2 = createNode(max_sentinel);

    root = node1;
    getNode(root).right = node2;
    updateSize(root);

    // 如果右孩子的优先级更大，左旋
    if (getNode(node1).priority < getNode(node2).priority) {
      rotateLeft(root);
    }
  }

  // 插入值
  constexpr void insert(const T& key) {
    insert(root, key);
  }

  // 删除值
  constexpr void erase(const T& key) {
    erase(root, key);
  }

  // 根据值找排名（1-based，需要减去哨兵）
  constexpr U getRank(const T& key) const {
    return getRank(root, key) - 1;  // 减去一个哨兵
  }

  // 根据排名找值（排名从1开始）
  constexpr T getByRank(U rank) const {
    return getByRank(root, rank + 1);  // 加上哨兵偏移
  }

  // 找第一个严格小于x的值（返回可选值，避免哨兵问题）
  constexpr std::optional<T> findPrev(const T& x) const {
    T result = findPrev(root, x, min_sentinel);
    if (isSentinel(result)) {
      return std::nullopt;
    }
    return result;
  }

  // 找第一个严格大于x的值（返回可选值，避免哨兵问题）
  constexpr std::optional<T> findNext(const T& x) const {
    T result = findNext(root, x, max_sentinel);
    if (isSentinel(result)) {
      return std::nullopt;
    }
    return result;
  }

  // 找第一个大于等于x的值（返回可选值，避免哨兵问题）
  constexpr std::optional<T> lowerBound(const T& x) const {
    T result = findLowerBound(root, x, max_sentinel);
    if (isSentinel(result)) {
      return std::nullopt;
    }
    return result;
  }

  // 找第一个小于等于x的值（返回可选值，避免哨兵问题）
  constexpr std::optional<T> upperBound(const T& x) const {
    T result = findUpperBound(root, x, min_sentinel);
    if (isSentinel(result)) {
      return std::nullopt;
    }
    return result;
  }

  // 旧的接口，直接返回值（保持兼容性，但可能返回哨兵）
  constexpr T findPrevDirect(const T& x) const {
    return findPrev(root, x, min_sentinel);
  }

  constexpr T findNextDirect(const T& x) const {
    return findNext(root, x, max_sentinel);
  }

  constexpr T lowerBoundDirect(const T& x) const {
    return findLowerBound(root, x, max_sentinel);
  }

  constexpr T upperBoundDirect(const T& x) const {
    return findUpperBound(root, x, min_sentinel);
  }

  // 检查是否为空
  constexpr bool empty() const {
    return nodes.empty() || (getNode(root).size == 2);  // 只有两个哨兵
  }

  // 获取大小（不包含哨兵）
  constexpr U size() const {
    if (nodes.empty()) return 0;
    return getNode(root).size - 2;  // 减去两个哨兵
  }

  // 清空树（重新初始化）
  constexpr void clear() {
    init();
  }

  // 检查是否存在
  constexpr bool contains(const T& key) const {
    int p = root;
    while (p != -1) {
      const auto& node = getNode(p);
      if (!compare(key, node.key) && !compare(node.key, key)) {
        return true;
      } else if (compare(key, node.key)) {
        p = node.left;
      } else {
        p = node.right;
      }
    }
    return false;
  }

  // 获取当前容量（用于调试）
  constexpr std::size_t capacity() const {
    return nodes.capacity();
  }

  // 预留空间
  constexpr void reserve(std::size_t n) {
    nodes.reserve(n);
  }

  // 获取节点数（包括哨兵）
  constexpr std::size_t nodeCount() const {
    return nodes.size();
  }

  // 获取哨兵值
  constexpr T getMinSentinel() const {
    return min_sentinel;
  }
  constexpr T getMaxSentinel() const {
    return max_sentinel;
  }

  // 设置哨兵值（需要重新初始化）
  constexpr void setSentinels(const T& min_val, const T& max_val) {
    min_sentinel = min_val;
    max_sentinel = max_val;
    clear();  // 重新初始化
  }

  // 检查是否为哨兵值
  constexpr bool isSentinelValue(const T& value) const {
    return isSentinel(value);
  }
};

// 静态成员初始化
template<class T, class U, class Compare>
std::mt19937 Treap<T, U, Compare>::rng;