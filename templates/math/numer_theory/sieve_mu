/**   莫比乌斯筛
 *    筛质数和莫比乌斯函数
 *    mu[i]存的是莫比乌斯函数前缀和
**/
std::vector<int> minp, primes;
std::vector<int> mu;

void sieve_mu(int n) {
  minp.assign(n + 1, 0);
  mu.assign(n + 1, 0);
  primes.clear();

  mu[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (minp[i] == 0) {
      minp[i] = i;
      mu[i] = -1;
      primes.push_back(i);
    }

    for (int p : primes) {
      if (i * p > n) break;
      minp[i * p] = p;

      if (p == minp[i]) {
        mu[i * p] = 0;
        break;
      } else {
        mu[i * p] = -mu[i];
      }
    }
  }

  std::partial_sum(mu.begin(), mu.end(), mu.begin());
}

bool isprime(int n) {
  return minp[n] == n;
}

/**   莫比乌斯函数（求解单个数的欧拉函数）
**/
template<typename T>
constexpr T mobius(T n) {
  T res = 1;
  for (T i = 2; i <= n / i; i++) {
    if (n % i == 0) {
      n /= i;
      if (n % i == 0) {
        return T{0};
      }
      res = -res;
    }
  }

  if (n > 1) {
    res = -res;
  }
  return res;
}