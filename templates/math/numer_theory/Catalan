/**
 *    需要前置自动取模类和组合数comb模板
**/

// 计算卡特兰数 C_n = (1/(n+1)) * C(2n, n)
// 使用公式：C_n = C(2n, n) - C(2n, n+1) （避免除法）
Z Catalan(int n) {
  if (n < 0) return 0;
  if (n == 0) return 1;
  
  // 确保组合数类已经初始化到 2n
  if (comb.n < 2 * n) {
    comb.init(2 * n);
  }
  
  // 使用公式：Catalan(n) = C(2n, n) - C(2n, n+1)
  // 这个公式避免了除法，在模运算下更安全
  return comb.binom(2 * n, n) - comb.binom(2 * n, n + 1);
}

// 使用递推公式的版本（需要除法，但计算更快）
Z CatalanRecurrence(int n) {
  if (n < 0) return 0;
  if (n == 0) return 1;
  
  // 递推公式：C_n = C_{n-1} * (4n-2) / (n+1)
  Z result = 1;
  for (int i = 1; i <= n; ++i) {
    result = result * (4 * i - 2) / (i + 1);
  }
  return result;
}

// 带记忆化的卡特兰数计算（适合多次查询）
struct CatalanCalculator {
  std::vector<Z> cache;
  
  void init(int max_n) {
    cache.resize(max_n + 1);
    cache[0] = 1;
    
    // 确保组合数类已经初始化到 2*max_n
    if (comb.n < 2 * max_n) {
      comb.init(2 * max_n);
    }
    
    // 使用递推公式预计算
    for (int i = 1; i <= max_n; ++i) {
      cache[i] = cache[i - 1] * (4 * i - 2) / (i + 1);
    }
  }
  
  Z get(int n) {
    if (n < 0) return 0;
    if (n < (int)cache.size()) {
      return cache[n];
    }
    // 如果超出缓存范围，使用组合数公式计算
    if (comb.n < 2 * n) {
      comb.init(2 * n);
    }
    return comb.binom(2 * n, n) - comb.binom(2 * n, n + 1);
  }
} catalan_calc;