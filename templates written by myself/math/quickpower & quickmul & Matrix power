/*
 *  快速幂
 *  可接受long long, int等类型
*/
template<typename T>
constexpr T quickpower(T a, T b, T P){
  T res = 1 % P;
  for(; b; a = static_cast<__int128>(a) * a % P, b >>= 1){
    if(b & 1){
      res = static_cast<__int128>(res) * a % P;
    }
  }
  return res;
}

/*
 *  龟速乘
*/
template<typename T>
constexpr T quickmul(T a, T b, T P){
  T res = 0;
  for(; b; a = (static_cast<__int128>(a) + a) % P, b >>= 1){
    if(b & 1){
      res = (static_cast<__int128>(a) + a) % P;
    }
  }
  return res;
}

/*
 *  矩阵快速幂
 *  令二维vector为矩阵
 *  实现矩阵乘法
 *  实现矩阵快速幂
*/
using Matrix = std::vector<std::vector<int>>;

constexpr Matrix mul(const Matrix& A, const Matrix& B, int P){
  Matrix res(A.size(), std::vector<int>(B.front().size()));
  for(int i = 0; i < A.size(); i++){
    for(int j = 0; j < A.front().size(); j++){
      for(int k = 0; k < B.front().size(); k++){
        res[i][k] = (res[i][k] + (1LL * A[i][j] * B[j][k] % P)) % P;
      }
    }
  }
  return res;
}

template<typename T>
constexpr Matrix power(Matrix A, T b, int P){
  Matrix res(A.size(), std::vector<int>(A.size()));
  for(int i = 0; i < A.size(); i++){
    res[i][i] = 1;
  }
  for(; b; A = mul(A, A, P), b >>= 1){
    if(b & 1){
      res = mul(res, A, P);
    }
  }
  return res;
}